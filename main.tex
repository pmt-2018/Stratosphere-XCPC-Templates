
\documentclass[twoside]{article}
\usepackage[colorlinks,linkcolor=black]{hyperref}
\usepackage{xeCJK}
\usepackage{fancyhdr}
\usepackage{amsmath, amsthm}
\usepackage{listings,xcolor}
\usepackage{geometry}
\usepackage{fontspec}
\usepackage{graphicx}
\setsansfont{Monaco}
\setmonofont[Mapping={}]{Monaco}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
\geometry{left=2.5cm,right=2.5cm,top=2.5cm,bottom=2.5cm}
\lstset{
    language    = c++,
    numbers     = left,
    numberstyle = \tiny,
    breaklines  = true,
    captionpos  = b,
    tabsize     = 4,
    frame       = single,
    columns     = fullflexible,
    commentstyle = \color[RGB]{0,128,0},
	keywordstyle ={
		\color[RGB]{0,51,153}
		\fontspec{Consolas Bold}	
	},
    basicstyle   = \small\ttfamily,
    stringstyle  = \color[RGB]{148,0,209}\ttfamily,
	rulesepcolor = \color{red!20!green!20!blue!20},
    showstringspaces = false,                    
}
\title{Stratosphere's XCPC Templates}
\author{平流层 Stratosphere}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[C]{Stratosphere's XCPC Templates, 平流层 Stratosphere}
\begin{document}\small
\begin{titlepage}
\begin{center}
\vspace*{0.5cm}\includegraphics[width=0.75\textwidth]{logo.jpg} \\ [2cm]
\HRule \\ [1cm]
\textbf{\Huge{Stratosphere's XCPC Templates}} \\ [0.5cm]
\HRule \\ [4cm]
\textbf{\Huge{南京大学}} \\ [1cm]
\LARGE{平流层 Stratosphere}
\vfill
\Large{\today}
\end{center}
\clearpage
\end{titlepage}
\tableofcontents\clearpage
\pagestyle{fancy}
\lfoot{}
\cfoot{\thepage}\rfoot{}
\setcounter{section}{-1}
\setcounter{page}{1}
\clearpage\section{Header与约定}
\clearpage\section{图论}
\subsection{欧拉回路}
\begin{lstlisting}
namespace Euler {
    bool directed;
    vector<pii> G[maxn];
    vector<int> ans;
    int vis[maxm];
    int dfs(int x) {
        vector<int> t;
        while (G[x].size()) {
            auto [to, id] = G[x].back();
            G[x].pop_back();
            if (!vis[abs(id)]) {
                vis[abs(id)] = 1, t.push_back(dfs(to)), ans.push_back(id);
            }
        }
        for (int i = 1; i < t.size(); i++) {
            if (t[i] != x) ans.clear();
        }
        return t.size() ? t[0] : x;
    }
    int n, m;
    pii e[maxm];
    int deg[maxn], vv[maxn];
    void clr() {
        for (int i = 1; i <= n; i++) G[i].clear(), deg[i] = vv[i] = 0;
        for (int i = 1; i <= m; i++) vis[i] = 0;
        ans.clear();
        n = m = 0;
    }
    void addedge(int x, int y) {
        chkmax(n, x), chkmax(n, y);
        ++m;
        e[m] = {x, y};
        if (directed) {
            G[x].push_back({y, m});
            ++deg[x], --deg[y], vv[x] = vv[y] = 1;
        } else {
            G[x].push_back({y, m});
            G[y].push_back({x, -m});
            ++deg[x], ++deg[y], vv[x] = vv[y] = 1;
        }
    }
    using vi = vector<int>;
    pair<vi, vi> work() {
        if (!m) return clr(), pair<vi, vi>{{1}, {}};
        int S = 1;
        for (int i = 1; i <= n; i++)
            if (vv[i]) S = i;
        for (int i = 1; i <= n; i++)
            if (deg[i] > 0 && deg[i] % 2 == 1) S = i;
        dfs(S);
        if ((int)ans.size() != m) return clr(), pair<vi, vi>();
        reverse(ans.begin(), ans.end());
        vi ver, edge = ans;
        if (directed) {
            ver = {e[ans[0]].fir};
            for (auto t : ans) ver.push_back(e[t].sec);
        } else {
            ver = {ans[0] > 0 ? e[ans[0]].fir : e[-ans[0]].sec};
            for (auto t : ans) ver.push_back(t > 0 ? e[t].sec : e[-t].fir);
        }
    }
}  // namespace Euler\end{lstlisting}
\subsection{Tarjan-SCC}
\begin{lstlisting}
void tarjan(int u) {
    dfn[u] = low[u] = ++tim;
    in[u] = 1;
    st[++top] = u;
    for (int v : G[u]) {
        if (!dfn[v])
            tarjan(v), ckmin(low[u], low[v]);
        else if (in[v])
            ckmin(low[u], dfn[v]);
    }
    if (dfn[u] == low[u]) {
        ++totc;
        int x;
        do { x = st[top--], in[x] = 0, bel[x] = totc; } while (x != u);
    }
}\end{lstlisting}
\subsection{点双}
\begin{lstlisting}
int T;  // assign = n
void tarjan(int u, int fa) {
    dfn[u] = low[u] = ++tim;
    stk[++top] = u;
    for (int v : G[u]) {
        if (v == fa) continue;
        if (!dfn[v])
            dfs(v, u), ckmin(low[u], low[v]);
        else
            ckmin(low[u], dfn[v]);
    }
    if (fa && low[u] >= dfn[fa]) {
        int y;
        ++T;
        do {
            y = stk[top--];
            G2[T].push_back(y), G2[y].push_back(T);
        } while (y != u);
        G2[T].push_back(fa), G2[fa].push_back(T);
    }
}\end{lstlisting}
\subsection{边双}
\begin{lstlisting}
// etot should be initialized to 1 !!!
void tarjan(int u, int f) {
    dfn[u] = low[u] = ++tim;
    for (int i = head[u]; i; i = e[i].nxt) {
        int v = e[i].to;
        if (v == f) continue;
        if (!dfn[v]) {
            tarjan(v, u);
            ckmin(low[u], low[v]);
            if (low[v] > dfn[u]) vis[i] = vis[i ^ 1] = 1;
        } else
            ckmin(low[u], dfn[v]);
    }
}
void fill(int u) {
    col[u] = cnt;
    for (int i = head[u]; i; i = e[i].nxt) {
        int v = e[i].to;
        if (col[v] || vis[i]) continue;
        fill(v);
    }
}\end{lstlisting}
\clearpage\section{数论}
\clearpage\section{数学}
\clearpage\section{字符串}
\clearpage\section{数据结构}
\clearpage\section{计算几何}
\clearpage\section{三维计算几何}
\clearpage\section{杂项}

\end{document}
